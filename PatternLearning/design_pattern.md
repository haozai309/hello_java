# Design Pattern







### 17. Decorator - 装饰模式

> 面向对象设计中，如果超过两层继承，就应该想想是不是出设计问题了。这是经验值，不是绝对的。继承层次越多以后，维护的成本越多。

动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。


优点：
* 装饰类和被装饰类可以独立发展，而不会相互耦合
* 装饰模式是继承关系的一个替代方案
* 可以动态的扩展一个实现类的功能

缺点：
* 尽量减少装饰类的数量，以便降低系统的复杂度。排查问题像剥洋葱。

场景：
* 需要扩展一个类的功能，或给一个类添加附加功能
* 需要动态地给一个对象增加功能，这些功能可以再动态的撤销
* 需要为一批的兄弟类进行改装和加装功能，当时是首选装饰模式

> 装饰模式是对继承的有力补充。继承是静态地给类增加功能，而装饰模式是动态地给类增加功能。


### 18. Stragety - 策略模式

定义一组算法，将每个算法都封装起来，并且是它们之间可以互换。

> 策略模式就是这么简单，采用了面向对象的继承和多态机制。但真实地业务环境哪有这么简单？一个类实现有多个接口，区分哪个接口是抽象策略接口，哪些是和策略模式没有任何关系，这就是作为系统分析师的价值所在。

优点
* 算法可以自由切换
* 避免使用多重条件判断
* 扩展性良好

缺点
* 策略类数量增多
* 所有的策略类都需要对外暴露

> 解决对外暴露的缺点 - 使用其他模式来修正，如工厂模式方法，代理模式或享元模式。


使用场景
* 多个类只有在算法或行为上稍有不同
* 算法需要自由切换。
  > 自由切换场景：例如，算法的选择是由使用者决定的，或者算法始终在进化，特别是一些站在技术前沿的行业。
* 需要屏蔽算法规则的场景

注意：如果一个策略家族中得具体策略数量超过4个，需要考虑使用混合模式，解决策略类膨胀和对外暴露的问题，否则日后的系统维护会成为一个烫手山芋，谁都不想接。


策略枚举：把原有定义在抽象策略中的方法移植到枚举中，每个枚举成员就成为一个具体策略。
> 一个非常优秀和方便的模式，但是收到枚举类型的限制，每个枚举项都是public、final、static的，扩展性收到了一定的约束，因此在系统开发中，策略枚举一般担当不经常发生变化的角色。


### 19. Adapter - 适配器模式

将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。

> 设计模式原是为建筑设计而服务的，软件设计模式只是借用了人家的原理而已。

优点：
* 让两个没有任何关系的类在一起运行
* 增加了类的透明性
* 提高了类的复用度
* 灵活性非常好

使用场景：有动机修改一个已经投产的接口。系统扩展了，不符合原有设计的时候才考虑通过适配器模式减少代码修改带来的风险。

注意事项：不是为了解决还处在开发阶段的问题，而是解决正在服役的项目问题。



### 20. Iterator 迭代器

迭代器模式目前已经是一个没落的模式，没人会单独写一个迭代器模式，除非是产品性质的开发。

能容纳对象的所有类型都可以称之为容器，例如Collection，Set。迭代器模式就是为解决遍历这些容器中的元素而诞生的。

迭代器类似一个数据库中的游标，可以在一个容器内上下翻滚，遍历所有要查看的元素。

> 做java开发，使用Iterator就好了。














