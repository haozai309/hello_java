# Design Pattern







### Decorator - 装饰模式

> 面向对象设计中，如果超过两层继承，就应该想想是不是出设计问题了。这是经验值，不是绝对的。继承层次越多以后，维护的成本越多。

动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。


优点：
* 装饰类和被装饰类可以独立发展，而不会相互耦合
* 装饰模式是继承关系的一个替代方案
* 可以动态的扩展一个实现类的功能

缺点：
* 尽量减少装饰类的数量，以便降低系统的复杂度。排查问题像剥洋葱。

场景：
* 需要扩展一个类的功能，或给一个类添加附加功能
* 需要动态地给一个对象增加功能，这些功能可以再动态的撤销
* 需要为一批的兄弟类进行改装和加装功能，当时是首选装饰模式

> 装饰模式是对继承的有力补充。继承是静态地给类增加功能，而装饰模式是动态地给类增加功能。


### Stragety - 策略模式

定义一组算法，将每个算法都封装起来，并且是它们之间可以互换。

> 策略模式就是这么简单，采用了面向对象的继承和多态机制。但真实地业务环境哪有这么简单？一个类实现有多个接口，区分哪个接口是抽象策略接口，哪些是和策略模式没有任何关系，这就是作为系统分析师的价值所在。

优点
* 算法可以自由切换
* 避免使用多重条件判断
* 扩展性良好

缺点
* 策略类数量增多
* 所有的策略类都需要对外暴露

> 解决对外暴露的缺点 - 使用其他模式来修正，如工厂模式方法，代理模式或享元模式。


使用场景
* 多个类只有在算法或行为上稍有不同
* 算法需要自由切换。
  > 自由切换场景：例如，算法的选择是由使用者决定的，或者算法始终在进化，特别是一些站在技术前沿的行业。
* 需要屏蔽算法规则的场景

注意：如果一个策略家族中得具体策略数量超过4个，需要考虑使用混合模式，解决策略类膨胀和对外暴露的问题，否则日后的系统维护会成为一个烫手山芋，谁都不想接。






